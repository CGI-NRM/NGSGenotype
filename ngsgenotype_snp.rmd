---
title: "ngsgenotype_snp"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Detect, load and clean files and genotypes:
```{r}
# Load libraries:
library(ShortRead)
library(wesanderson)
source("genotyping_functions.r")

# Load all samples: # some negatives and positives are summarized if they are named the same
snpCsvFiles <- list.files("Genotyped_SNPs/", pattern = ".csv", full.names = TRUE)
loadedFiles <- lapply(snpCsvFiles, read.table, sep = ',', header = TRUE, check.names = FALSE)
allGenotypes <- do.call(rbind, loadedFiles)
allGenotypes[is.na(allGenotypes)] <- ''

# Remove controls:
removedSampleInfo <- list(startNumber = nrow(allGenotypes)) # does not include some duplicates which were removed in genotyping
removedSampleInfo$nControls <- sum(grepl("NEGATIVE|POSITIVE", allGenotypes$Sample))
sampleGenotypes <- allGenotypes[!grepl("NEGATIVE|POSITIVE", allGenotypes$Sample), ]

# Fix sample name:
sampleGenotypes$Sample <- toupper(sampleGenotypes$Sample)
# sampleGenotypes$Sample[grepl("^M", sampleGenotypes$Sample)] <- substr(sampleGenotypes$Sample[grepl("^M", sampleGenotypes$Sample)], 1, 7)

# Remove duplicates:
removedSampleInfo$nDuplicated <- sum(duplicated(sampleGenotypes$Sample))
# print(sampleGenotypes$Sample[duplicated(sampleGenotypes$Sample)]) # all names that are duplicates of other names
sampleGenotypes <- sampleGenotypes[!duplicated(sampleGenotypes$Sample), ] # only keep the first of duplicated names
# or:
# allGenotypes$Sample <- make.names(allGenotypes$Sample, unique = TRUE) # give duplications unique names

# Remove based on 
```

# Filter samples and loci:
```{r}
# Filter out sex loci:
sexString <- "Ua-snp-01y|Ua-snp-02y|Ua-snp-03y|Ua-snp-04y|Ua-snp-196-x|Ua-snp-248-x|Ua-snp-236-x"
autoGenotypes <- sampleGenotypes[, !grepl(sexString, colnames(sampleGenotypes))]
saveRDS(autoGenotypes, file = "autoGenotypes.rds")
sexGenotypes <- cbind(Sample = sampleGenotypes$Sample, sampleGenotypes[, grepl(sexString, colnames(sampleGenotypes))])
saveRDS(sexGenotypes, file = "sexGenotypes.rds")

# Filter out samples with minimum 75/67 working loci:
filteredGenotypes75 <- GenotypeFiltering(autoGenotypes, minPresent = 75, createRDS = TRUE, rdsName = "filteredGenotypes75.rds")
filteredGenotypes67 <- GenotypeFiltering(autoGenotypes, minPresent = 67, maxPresent = 74, createRDS = FALSE)
filteredGenotypesAll <- GenotypeFiltering(autoGenotypes, minPresent = 67, createRDS = FALSE)

# Filter out rejected genotypes:
rejectedGenotypes <- GenotypeFiltering(autoGenotypes, minPresent = 0, maxPresent = 66, createRDS = TRUE, rdsName = "rejectedGenotypes.rds")
removedSampleInfo$nLowQuality <- nrow(rejectedGenotypes)
filteredGenotypes00 <- GenotypeFiltering(autoGenotypes, minPresent = 0, maxPresent = 23, createRDS = FALSE)
filteredGenotypes24 <- GenotypeFiltering(autoGenotypes, minPresent = 24, maxPresent = 66, createRDS = FALSE)

# Filter out empty loci:
presentGenotypes75 <- filteredGenotypes75[, !lapply(filteredGenotypes75, unique) == ''] # does this matter with allelematch?
presentGenotypesAll <- filteredGenotypesAll[, !lapply(filteredGenotypesAll, unique) == ''] # does this matter with allelematch?
```

# Collapse samples to individuals based on high quality samples (>= 75 working loci):
```{r}
library(allelematch)

SplitLocus <- function(x, dataSet) {
  columnName <- colnames(dataSet)[x]
  print(columnName)
  twoCols <- do.call(rbind, strsplit(dataSet[, x], ""))
  colnames(twoCols) <- c(paste0(columnName, "1"), paste0(columnName, "2"))
  return(twoCols)
}

LoadAMData <- function(inData) {
  # Split loci into two columns:
  inData[inData == ''] <- "NN" # change missing data to NN
  splitDataset <- cbind(Sample = inData$Sample, do.call(cbind, lapply(1:ncol(inData[, -c(1)]), SplitLocus, inData[, -c(1)])))
  
  # Load data:
  snpLoadedSplit <- allelematch::amDataset(multilocusDataset = splitDataset, missingCode = "N", indexColumn = "Sample")
  bearAlleleKey <- rep(1:(ncol(splitDataset[, -c(1)]) / 2), each = 2)
  return(list(Data = snpLoadedSplit, AlleleKey = bearAlleleKey))
}

# Load data into allelematch:
loadedData75 <- LoadAMData(presentGenotypes75)

# Find optimal mismatch parameters (optional):
amProfile75 <- allelematch::amUniqueProfile(amDatasetFocal = loadedData75$Data, multilocusMap = loadedData75$AlleleKey, doPlot = TRUE, alleleMismatch = c(0:45)) # 13 is the best
saveRDS(amProfile75, file = "amProfile75.rds")
mmCutoff <- amProfile75$alleleMismatch[amProfile75$guessOptimum]

# Cluster samples with allelematch:
# uniqueBears75 <- allelematch::amUnique(loadedData75$Data, multilocusMap = loadedData75$AlleleKey, alleleMismatch = mmCutoff) # uncomment if using calculated cutoff
uniqueBears75 <- allelematch::amUnique(loadedData75$Data, multilocusMap = loadedData75$AlleleKey, alleleMismatch = 10) # changed cutoff to 10 to be more stringent
saveRDS(uniqueBears75, file = "uniqueBears75_10.rds")
allelematch::summary.amUnique(object = uniqueBears75, html = "unique_bears_75_10_v1.html")
allelematch::summary.amUnique(object = uniqueBears75, csv = "unique_bears_75_10_v1.csv")
```














