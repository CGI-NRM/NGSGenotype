---
title: "ngsgenotype_snp"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load libraries and settings:
```{r}
library(ShortRead)
library(wesanderson)

filteredFolder <- "./Filtered_data/SNP_filtered/"
```

# Detect files:
```{r}
inputFiles <- list.files(filteredFolder, pattern = ".fastq.gz")
```

# Load files:
```{r}
FastqLoader <- function(fileName, pathToData = filteredFolder) {
  loadedFile <- ShortRead::readFastq(dirPath = pathToData, pattern = fileName)
  print(paste("Searching for", fileName))
  print(paste("Found", length(list.files(pathToData, pattern = fileName)), "files."))
  return(c(loadedFile, fileName))
}

PickGenotype <- function(srVector, cutoff) {
  srObject <- srVector[[1]]
  srTable <- ShortRead::tables(srObject)$top
  if(length(srTable) > 1) {
    topSNP <- srTable[1]
    sndSNP <- srTable[2]
  } else if(length(srTable) == 1) {
    topSNP <- srTable[1]
    sndSNP <- srTable[1]
  } else {
    topSNP <- 0
    sndSNP <- 0
  }
  if((topSNP + sndSNP) > cutoff[1]) {
    if(((sndSNP / topSNP) * 100) > cutoff[2]) { # if a heterozygote or if there was only one top nucleotide
      # print(paste0(sort(c(names(topSNP), names(sndSNP))), collapse = ""))
      return(c(srVector[[2]], paste0(sort(c(names(topSNP), names(sndSNP))), collapse = "")))
      # return(c(srVector[[2]], paste0(names(topSNP), names(sndSNP))))
    } else { # if a homozygote
      # return(c(srVector[[2]], names(topSNP), names(topSNP)))
      return(c(srVector[[2]], paste0(names(topSNP), names(topSNP))))
    }
  } else {
    # return(c(srVector[[2]], "-", "-"))
    return(c(srVector[[2]], ""))
    # return(c(srVector[[2]], NA))
  }
}

RunLocus <- function(locusName, allFiles, filteredFolder, locusCutoffs = c()) {
  print(paste0("Running locus: ", locusName))
  locusFiles <- allFiles[grepl(locusName, inputFiles)]
  loadedFastqFiles <- lapply(locusFiles, FastqLoader, filteredFolder)
  if(locusName %in% names(locusCutoffs)) { # if a specific cutoff is set for this locus
    cutoff = locusCutoffs[locusName][[1]]
  } else { # else use standard settings
    cutoff = c(10, 1) # minimum 10 reads, minimum 10% to be a heterozygote
  }
  genotypeRes <- lapply(loadedFastqFiles, PickGenotype, cutoff)
  rm(loadedFastqFiles) # remove to conserve memory
  gc() # run garbage collection to free memory
  genotypeCols <- do.call(rbind, genotypeRes)
  genotypeCols <- as.data.frame(genotypeCols)
  # colnames(genotypeCols) <- c("Sample", paste0(locusName, "_1"), paste0(locusName, "_2"))
  colnames(genotypeCols) <- c("Sample", locusName)
  genotypeCols$Sample <- gsub(".+_|BMK.+", "", genotypeCols$Sample)
  return(genotypeCols)
}

RunAllLoci <- function(inputFiles, filteredFolder, locusCutoffs = c()) {
  lociNames <- unique(gsub("_.+", "", inputFiles)) # remove everything after and including the first underscore
  genotypesList <- lapply(lociNames, RunLocus, inputFiles, filteredFolder, locusCutoffs)
  allGenotypes <- Reduce(function(x, y) merge(x, y, by = "Sample"), genotypesList)
  return(allGenotypes)
}

# Specify if any loci should have specific cutoffs:
locusCutoffs <- c()
locusCutoffs <- rep(list(c(10, 20)), length(unique(gsub("_.+", "", inputFiles)))) # minimum 10 reads, minimum 20% to be heterozygote
names(locusCutoffs) <- unique(gsub("_.+", "", inputFiles))
locusCutoffs
# locusCutoffs$`locus name` <- c(10, 10) # add 'locus name' and its designated cutoffs

# Load all samples and calculate all loci:
allGenotypes <- RunAllLoci(inputFiles, filteredFolder, locusCutoffs)

# If genotypes are returned as only one letter it is because of the fact that there are empty reads in the fastq
```

# Distance function:
```{r}
CompareBears <- function(bear1, bear2, snpFrame) {
  CheckDiff <- function(allelePair) {
    x <- allelePair[1]
    y <- allelePair[2]
    if((x == y) && (x != "") && (y != "")) { # if alleles are nonempty and the same
      return(1) # count one similarity
    } else {
      return(0) # count zero similarities
    }
  }
  similarities <- lapply(rbind(snpFrame[bear1, ], snpFrame[bear2, ])[, -c(1)], CheckDiff)
  simSum <- sum(unlist(similarities)) # number of shared alleles between the two samples
  return((ncol(snpFrame) - 1) - simSum) # return number of non shared alleles between the two samples
}

BearDist <- function(snpFrame) { # function that generates a dist object with how many loci differ and or are missing between individuals
  sampNames <- snpFrame$Sample
  nSamples <- length(sampNames)
  bearDiffs <- c()
  for(current in 1:(nSamples - 1)) {
    remainingIndices <- (1:nSamples)[(current + 1):nSamples]
    bearDiffs <- c(bearDiffs, lapply(remainingIndices, CompareBears, current, snpFrame))
    # print(paste0(current, ":", remainingIndices))
  }
  bearMatrix <- matrix(data = 0, nrow = nSamples, ncol = nSamples)
  colnames(bearMatrix) <- sampNames
  rownames(bearMatrix) <- sampNames
  bearDistObject <- as.dist(bearMatrix)
  bearDistObject[] <- unlist(bearDiffs) # fill dist object with distance values
  return(bearDistObject)
}

# BearDist(allGenotypes) # usage
```

# Initial steps to collapsing individuals:
```{r}
library(poppr)
library(adegenet)

# Load data:
genotypeGenind <- adegenet::df2genind(allGenotypes[, -c(1)], ploidy = 2, ind.names = allGenotypes$Sample, sep = "")
genotypeGenind
genotypeGencln <- poppr::as.genclone(genotypeGenind)
genotypeGencln

# Collapse genotypes:
mll(genotypeGencln) <- "original" # reset genotypes
hist(BearDist(allGenotypes)) # histogram of BearDists (TM)
threshold <- (ncol(allGenotypes) - 1) - 67 # make a threshold where 67 loci needs to be similar between samples
mlg.filter(genotypeGencln, distance = BearDist(allGenotypes)) <- threshold # collapse based on threshold, using BearDists (TM)
genotypeGencln
mll(genotypeGencln)

# Assign genotypes:
gtAndSnps <- as.data.frame(cbind(genotypes = genotypeGencln@mlg@mlg$contracted, genotypeGencln$tab)) # add genotypes to SNP table
uniqueSamples <- rownames(gtAndSnps)[match(unique(gtAndSnps$genotypes), gtAndSnps$genotypes)] # take first sample of each genotype
# Pull those samples from the sample sheets

# Mockup:
# 1. add a column to the "database" with ind-names
# 2. load the "database" (without ind-names) and new samples together
# 3. collapse individuals (will collapse the new ones to an existing genotype)
# 4. check if collapsed genotypes contain a sample with an existing ind-name, if so add new ones to database under that name
# 5. if individuals do not exist, add them to database with new names.
```
